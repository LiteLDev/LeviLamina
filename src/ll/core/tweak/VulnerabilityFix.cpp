#include "ll/api/memory/Hook.h"
#include "mc/certificates/UnverifiedCertificate.h"
#include "mc/nbt/CompoundTag.h"
#include "mc/nbt/NbtIo.h"
#include "mc/util/IDataInput.h"
#include "mc/world/item/Item.h"
#include "mc/world/item/ItemStackBase.h"
#include "nlohmann/json.hpp"

namespace ll::vulnerability_fix {
LL_TYPE_STATIC_HOOK(
    UnverifiedCertificateHook,
    HookPriority::Highest,
    UnverifiedCertificate,
    &UnverifiedCertificate::fromString,
    UnverifiedCertificate,
    std::string const& input
) {
    if (input.size() <= 0x300000) {
        try {
            auto json = nlohmann::json::parse(input);
            if (json.is_object()) {
                auto& chain = json["chain"];
                if (chain.is_array() && chain.size() <= 3) {
                    return origin(input);
                }
            }
        } catch (...) {}
    }
    return {WebToken(), nullptr};
}

LL_TYPE_INSTANCE_HOOK(
    ReadUserDataHook,
    HookPriority::Highest,
    Item,
    &Item::$readUserData,
    void,
    ItemStackBase& stack,
    IDataInput&    input,
    ReadOnlyBinaryStream&
) {
    auto marker_result = input.readShortResult();
    if (!marker_result.has_value()) {
        return;
    }
    if (marker_result.value() == -1) {
        auto version_result = input.readByteResult();
        if (!version_result.has_value()) {
            return;
        }
        if (version_result.value() != 1) {
            return;
        }
        if (auto tags = NbtIo::readOrGetEmpty(input)) {
            stack.setUserData(std::move(tags));
        }
    } else if (marker_result.value() != 0) {
        // legacy format?
        return;
    }
    stack.deserializeComponents(input);
}

using HookReg = memory::HookRegistrar<UnverifiedCertificateHook, ReadUserDataHook>;

static HookReg hookRegister;
} // namespace ll::vulnerability_fix
