#include "ll/api/event/EventBus.h"
#include "ll/api/event/server/ServerStartedEvent.h"
#include "ll/api/memory/Hook.h"
#include "ll/api/service/Bedrock.h"
#include "mc/certificates/UnverifiedCertificate.h"
#include "mc/deps/raknet/RakPeerInterface.h"
#include "mc/nbt/CompoundTag.h"
#include "mc/nbt/NbtIo.h"
#include "mc/network/NetworkConnection.h"
#include "mc/network/RakPeerHelper.h"
#include "mc/network/ServerNetworkHandler.h"
#include "mc/network/ServerNetworkSystem.h"
#include "mc/server/commands/Command.h"
#include "mc/server/commands/CommandOutput.h"
#include "mc/server/commands/CommandVersion.h"
#include "mc/server/commands/MinecraftCommands.h"
#include "mc/server/commands/ServerCommandOrigin.h"
#include "mc/util/IDataInput.h"
#include "mc/world/Minecraft.h"
#include "mc/world/item/Item.h"
#include "mc/world/item/ItemStackBase.h"
#include "nlohmann/json.hpp"

namespace ll::vulnerability_fixes {
LL_TYPE_STATIC_HOOK(
    UnverifiedCertificateHook,
    HookPriority::Highest,
    UnverifiedCertificate,
    &UnverifiedCertificate::fromString,
    UnverifiedCertificate,
    std::string const& input
) {
    if (input.size() <= 0x300000) {
        try {
            auto json = nlohmann::json::parse(input);
            if (json.is_object()) {
                auto& chain = json["chain"];
                if (chain.is_array() && chain.size() <= 3) {
                    return origin(input);
                }
            }
        } catch (...) {}
    }
    return {WebToken(), nullptr};
}

LL_TYPE_INSTANCE_HOOK(
    ReadUserDataHook,
    HookPriority::Highest,
    Item,
    &Item::$readUserData,
    void,
    ItemStackBase& stack,
    IDataInput&    input,
    ReadOnlyBinaryStream&
) {
    auto marker_result = input.readShortResult();
    if (!marker_result.has_value()) {
        return;
    }
    if (marker_result.value() == -1) {
        auto version_result = input.readByteResult();
        if (!version_result.has_value()) {
            return;
        }
        if (version_result.value() != 1) {
            return;
        }
        if (auto tags = NbtIo::readOrGetEmpty(input)) {
            stack.setUserData(std::move(tags));
        }
    } else if (marker_result.value() != 0) {
        // legacy format?
        return;
    }
    stack.deserializeComponents(input);
}

LL_TYPE_INSTANCE_HOOK(
    ReceivePacketHook,
    HookPriority::Highest,
    NetworkConnection,
    &NetworkConnection::receivePacket,
    NetworkPeer::DataStatus,
    std::string&                                                    receiveBuffer,
    std::shared_ptr<::std::chrono::steady_clock::time_point> const& timepointPtr
) {
    if (mDisconnected) {
        return NetworkPeer::DataStatus::NoData;
    }
    return origin(receiveBuffer, timepointPtr);
}

LL_TYPE_INSTANCE_HOOK(
    DisconnectClientHook,
    HookPriority::Highest,
    ServerNetworkHandler,
    &ServerNetworkHandler::disconnectClientWithMessage,
    void,
    NetworkIdentifier const&         id,
    SubClientId                      subId,
    Connection::DisconnectFailReason discoReason,
    std::string const&               message,
    std::optional<::std::string>     filteredMessage,
    bool                             skipMessage
) {
    origin(id, subId, discoReason, message, filteredMessage, skipMessage);
    // BUGFIX:
    // Forcibly mark the connection as disconnected immediately so no further packets from this client are accepted or
    // processed. The original code sends a disconnection notification to the client, but a malicious client may ignore
    // it and keep sending packets. The system still processes incoming packets afterward, which leaves the server
    // vulnerable to continued packet spam.
    if (auto* connection = mNetwork.getConnectionFromId(id); connection) {
        connection->mDisconnected = true;
    }
}

LL_TYPE_INSTANCE_HOOK(
    PeerStartupHook,
    HookPriority::Highest,
    RakPeerHelper,
    &RakPeerHelper::peerStartup,
    RakNet::StartupResult,
    RakNet::RakPeerInterface*   peerIn,
    ConnectionDefinition const& definition,
    RakPeerHelper::PeerPurpose  purpose
) {
    if (peerIn && purpose == PeerPurpose::Gameplay) {
        peerIn->SetLimitIPConnectionFrequency(true); // limit connections from the same ip in 100 milliseconds.
    }
    return origin(peerIn, definition, purpose);
}

void enableFixes() {
    static memory::HookRegistrar<
        UnverifiedCertificateHook,
        ReadUserDataHook,
        ReceivePacketHook,
        DisconnectClientHook,
        PeerStartupHook>
        registrar;
    event::EventBus::getInstance().emplaceListener<event::server::ServerStartedEvent>(
        [](event::server::ServerStartedEvent&) {
            // enable packet rate limi
            ServerCommandOrigin origin("Server", ll::service::getLevel()->asServer(), CommandPermissionLevel::Owner, 0);
            auto                command = ll::service::getMinecraft()->mCommands->compileCommand(
                "reloadpacketlimitconfig",
                origin,
                (CurrentCmdVersion)CommandVersion::CurrentVersion(),
                [&](std::string const&) {}
            );
            CommandOutput output(CommandOutputType::Silent);
            command->run(origin, output);
        }
    );
}
} // namespace ll::vulnerability_fixes
