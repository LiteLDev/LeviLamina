#pragma once

#include "mc/_HeaderOutputPredefine.h"

// auto generated inclusion list
#include "mc/legacy/ActorUniqueID.h"
#include "mc/world/level/BlockPos.h"
#include "mc/world/level/dimension/end/EndDragonFightVersion.h"
#include "mc/world/level/dimension/end/RespawnAnimation.h"

// auto generated forward declare list
// clang-format off
class ActorDamageSource;
class ActorSoundIdentifier;
class BlockPatternBuilder;
class BlockSource;
class ChunkPos;
class ChunkViewSource;
class CompoundTag;
class EnderCrystal;
class EnderDragon;
struct BuildMatch;
// clang-format on

class EndDragonFight {
public:
    // EndDragonFight inner types declare
    // clang-format off
    struct GateWayGenerator;
    // clang-format on

    // EndDragonFight inner types define
    struct GateWayGenerator {
    public:
        // member variables
        // NOLINTBEGIN
        ::ll::UntypedStorage<1, 1>  mUnk581d19;
        ::ll::UntypedStorage<8, 8>  mUnk1cd584;
        ::ll::UntypedStorage<4, 12> mUnkc5e5b6;
        // NOLINTEND

    public:
        // prevent constructor by default
        GateWayGenerator& operator=(GateWayGenerator const&);
        GateWayGenerator(GateWayGenerator const&);
        GateWayGenerator();

    public:
        // member functions
        // NOLINTBEGIN
        MCNAPI ~GateWayGenerator();
        // NOLINTEND

    public:
        // destructor thunk
        // NOLINTBEGIN
        MCNAPI void $dtor();
        // NOLINTEND
    };

    enum class GatewayTask : uchar {
        GeneratePair = 0,
        VerifyPair   = 1,
        NoTask       = 2,
    };

public:
    // member variables
    // NOLINTBEGIN
    ::ll::TypedStorage<8, 8, ::BlockSource*>                           mRegion;
    ::ll::TypedStorage<8, 24, ::std::vector<int>>                      mGateways;
    ::ll::TypedStorage<8, 8, ::std::unique_ptr<::BlockPatternBuilder>> mExitPortalPattern;
    ::ll::TypedStorage<4, 4, int>                                      mNumCrystalsAlive;
    ::ll::TypedStorage<4, 4, int>                                      mTicksSinceCrystalsScanned;
    ::ll::TypedStorage<4, 4, int>                                      mTicksSincePortalScanned;
    ::ll::TypedStorage<4, 4, int>                                      mTicksSinceLastPlayerScan;
    ::ll::TypedStorage<1, 1, bool>                                     mDragonKilled;
    ::ll::TypedStorage<1, 1, bool>                                     mPreviouslyKilled;
    ::ll::TypedStorage<1, 1, bool>                                     mDragonSpawned;
    ::ll::TypedStorage<8, 8, ::ActorUniqueID>                          mDragonUUID;
    ::ll::TypedStorage<4, 12, ::BlockPos>                              mPortalLocation;
    ::ll::TypedStorage<4, 12, ::BlockPos const>                        mDragonSpawnPos;
    ::ll::TypedStorage<4, 4, ::RespawnAnimation>                       mRespawnStage;
    ::ll::TypedStorage<4, 4, int>                                      mRespawnTime;
    ::ll::TypedStorage<8, 24, ::std::vector<::ActorUniqueID>>          mRespawnCrystals;
    ::ll::TypedStorage<1, 1, ::EndDragonFightVersion>                  mFightVersion;
    ::ll::TypedStorage<8, 32, ::EndDragonFight::GateWayGenerator>      mEntryGenerator;
    ::ll::TypedStorage<8, 32, ::EndDragonFight::GateWayGenerator>      mExitGenerator;
    ::ll::TypedStorage<1, 1, ::EndDragonFight::GatewayTask>            mBuildingOrVerifyingEndGatewayPair;
    ::ll::TypedStorage<
        8,
        40,
        ::std::deque<::std::tuple<
            ::EndDragonFight::GatewayTask,
            ::EndDragonFight::GateWayGenerator,
            ::EndDragonFight::GateWayGenerator>>>
        mGatewayTasks;
    // NOLINTEND

public:
    // prevent constructor by default
    EndDragonFight();

public:
    // member functions
    // NOLINTBEGIN
    MCAPI explicit EndDragonFight(::BlockSource& level);

    MCAPI bool _areaIsLoaded(::ChunkPos const& center, ::ChunkViewSource& source, int radius) const;

    MCAPI bool _canSpawnNewGateway(::ChunkViewSource* source, ::BlockPos const& pos) const;

    MCAPI void _createNewDragon();

    MCAPI ::BuildMatch _findExitPortal();

    MCAPI void _initializeDragon(::EnderDragon& enderDragon);

    MCAPI void _makeEndIslandFeature(::BlockSource& region, ::BlockPos position);

    MCAPI ::ActorSoundIdentifier _makeSoundIdentifier() const;

    MCAPI void _placeAndLinkNewGatewayPair();

    MCAPI bool _setEndGatewayBlockActorExitPosition(
        ::BlockSource&    entrySource,
        ::BlockSource&    exitSource,
        ::BlockPos const& endGatewayActorPos,
        ::BlockPos const& destinationPos,
        bool              lookForGateway
    );

    MCAPI void _setRespawnStage(::RespawnAnimation stage);

    MCAPI void _spawnExitPortal(bool activated);

    MCAPI void _spawnNewGatewayChunksTask(
        ::std::tuple<
            ::EndDragonFight::GatewayTask,
            ::EndDragonFight::GateWayGenerator,
            ::EndDragonFight::GateWayGenerator>& task
    );

    MCAPI void _spawnNewGatewayPair();

    MCAPI void _tickRespawnAnimation(::std::vector<::ActorUniqueID> const& crystalIDs, int time);

    MCAPI void _updateCrystalCount();

    MCAPI void _verifyExitPositionsTask(
        ::std::tuple<
            ::EndDragonFight::GatewayTask,
            ::EndDragonFight::GateWayGenerator,
            ::EndDragonFight::GateWayGenerator>& task
    );

    MCAPI void loadData(::CompoundTag const& tag);

    MCAPI void onCrystalDestroyed(::EnderCrystal const& crystal, ::ActorDamageSource const& source);

    MCAPI void resetSpikeCrystals();

    MCAPI void saveData(::CompoundTag& tag);

    MCAPI void spawnNewGatewayChunks(::BlockPos const& pos, bool placeEntryBlocks, bool placeExitBlocks);

    MCAPI void tick();

    MCAPI void tryRespawn();

    MCAPI ~EndDragonFight();
    // NOLINTEND

public:
    // static variables
    // NOLINTBEGIN
    MCAPI static ::BlockPos const& DEFAULT_PORTAL_LOCATION();
    // NOLINTEND

public:
    // constructor thunks
    // NOLINTBEGIN
    MCAPI void* $ctor(::BlockSource& level);
    // NOLINTEND

public:
    // destructor thunk
    // NOLINTBEGIN
    MCAPI void $dtor();
    // NOLINTEND
};
