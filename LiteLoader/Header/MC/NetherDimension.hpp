// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#define AUTO_GENERATED
#include "../Global.h"

#define BEFORE_EXTRA
// Include Headers or Declare Types Here

#undef BEFORE_EXTRA

class NetherDimension {

#define AFTER_EXTRA
// Add Member There

#undef AFTER_EXTRA

#ifndef DISABLE_CONSTRUCTOR_PREVENTION_NETHERDIMENSION
public:
    class NetherDimension& operator=(class NetherDimension const&) = delete;
    NetherDimension(class NetherDimension const&) = delete;
    NetherDimension() = delete;
#endif

public:
    /*
    inline bool showSky() const{
        bool (NetherDimension::*rv)() const;
        *((void**)&rv) = dlsym("?showSky@NetherDimension@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isNaturalDimension() const{
        bool (NetherDimension::*rv)() const;
        *((void**)&rv) = dlsym("?isNaturalDimension@NetherDimension@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool mayRespawnViaBed() const{
        bool (NetherDimension::*rv)() const;
        *((void**)&rv) = dlsym("?mayRespawnViaBed@NetherDimension@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline bool isValidSpawn(int a0, int a1) const{
        bool (NetherDimension::*rv)(int, int) const;
        *((void**)&rv) = dlsym("?isValidSpawn@NetherDimension@@UEBA_NHH@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<int>(a1));
    }
    inline bool isFoggyAt(int a0, int a1) const{
        bool (NetherDimension::*rv)(int, int) const;
        *((void**)&rv) = dlsym("?isFoggyAt@NetherDimension@@UEBA_NHH@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<int>(a1));
    }
    inline bool forceCheckAllNeighChunkSavedStat() const{
        bool (NetherDimension::*rv)() const;
        *((void**)&rv) = dlsym("?forceCheckAllNeighChunkSavedStat@NetherDimension@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline void _upgradeOldLimboEntity(class CompoundTag& a0, enum LimboEntitiesVersion a1){
        void (NetherDimension::*rv)(class CompoundTag&, enum LimboEntitiesVersion);
        *((void**)&rv) = dlsym("?_upgradeOldLimboEntity@NetherDimension@@EEAAXAEAVCompoundTag@@W4LimboEntitiesVersion@@@Z");
        return (this->*rv)(std::forward<class CompoundTag&>(a0), std::forward<enum LimboEntitiesVersion>(a1));
    }
    inline std::unique_ptr<class ChunkSource> _wrapStorageForVersionCompatibility(std::unique_ptr<class ChunkSource> a0, enum StorageVersion a1){
        std::unique_ptr<class ChunkSource> (NetherDimension::*rv)(std::unique_ptr<class ChunkSource>, enum StorageVersion);
        *((void**)&rv) = dlsym("?_wrapStorageForVersionCompatibility@NetherDimension@@EEAA?AV?$unique_ptr@VChunkSource@@U?$default_delete@VChunkSource@@@std@@@std@@V23@W4StorageVersion@@@Z");
        return (this->*rv)(std::forward<std::unique_ptr<class ChunkSource>>(a0), std::forward<enum StorageVersion>(a1));
    }
    inline class std::tuple<std::unique_ptr<class ChunkSource>, class WorldGenerator* > createGenerator(){
        class std::tuple<std::unique_ptr<class ChunkSource>, class WorldGenerator* > (NetherDimension::*rv)();
        *((void**)&rv) = dlsym("?createGenerator@NetherDimension@@UEAA?AV?$tuple@V?$unique_ptr@VChunkSource@@U?$default_delete@VChunkSource@@@std@@@std@@PEAVWorldGenerator@@@std@@XZ");
        return (this->*rv)();
    }
    inline void fixWallChunk(class ChunkSource& a0, class LevelChunk& a1){
        void (NetherDimension::*rv)(class ChunkSource&, class LevelChunk&);
        *((void**)&rv) = dlsym("?fixWallChunk@NetherDimension@@UEAAXAEAVChunkSource@@AEAVLevelChunk@@@Z");
        return (this->*rv)(std::forward<class ChunkSource&>(a0), std::forward<class LevelChunk&>(a1));
    }
    inline int getDefaultBiome() const{
        int (NetherDimension::*rv)() const;
        *((void**)&rv) = dlsym("?getDefaultBiome@NetherDimension@@UEBAHXZ");
        return (this->*rv)();
    }
    inline float getTimeOfDay(int a0, float a1) const{
        float (NetherDimension::*rv)(int, float) const;
        *((void**)&rv) = dlsym("?getTimeOfDay@NetherDimension@@UEBAMHM@Z");
        return (this->*rv)(std::forward<int>(a0), std::forward<float>(a1));
    }
    inline void init(){
        void (NetherDimension::*rv)();
        *((void**)&rv) = dlsym("?init@NetherDimension@@UEAAXXZ");
        return (this->*rv)();
    }
    inline class Vec3 translatePosAcrossDimension(class Vec3 const& a0, class AutomaticID<class Dimension, int> a1) const{
        class Vec3 (NetherDimension::*rv)(class Vec3 const&, class AutomaticID<class Dimension, int>) const;
        *((void**)&rv) = dlsym("?translatePosAcrossDimension@NetherDimension@@UEBA?AVVec3@@AEBV2@V?$AutomaticID@VDimension@@H@@@Z");
        return (this->*rv)(std::forward<class Vec3 const&>(a0), std::forward<class AutomaticID<class Dimension, int>>(a1));
    }
    inline void upgradeLevelChunk(class ChunkSource& a0, class LevelChunk& a1, class LevelChunk& a2){
        void (NetherDimension::*rv)(class ChunkSource&, class LevelChunk&, class LevelChunk&);
        *((void**)&rv) = dlsym("?upgradeLevelChunk@NetherDimension@@UEAAXAEAVChunkSource@@AEAVLevelChunk@@1@Z");
        return (this->*rv)(std::forward<class ChunkSource&>(a0), std::forward<class LevelChunk&>(a1), std::forward<class LevelChunk&>(a2));
    }
    */

protected:

private:

};