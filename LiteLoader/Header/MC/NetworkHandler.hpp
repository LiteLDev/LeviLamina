// This Header is auto generated by BDSLiteLoader Toolchain
#pragma once
#define AUTO_GENERATED
#include "../Global.h"
#include "Bedrock.hpp"

#define BEFORE_EXTRA
// Include Headers or Declare Types Here

#undef BEFORE_EXTRA

class NetworkHandler {

#define AFTER_EXTRA
// Add Member There
public:
class Connection {
public:
    Connection() = delete;
    Connection(Connection const&) = delete;
    Connection(Connection const&&) = delete;
};

#undef AFTER_EXTRA

#ifndef DISABLE_CONSTRUCTOR_PREVENTION_NETWORKHANDLER
public:
    class NetworkHandler& operator=(class NetworkHandler const &) = delete;
    NetworkHandler(class NetworkHandler const &) = delete;
    NetworkHandler() = delete;
#endif

public:
    /*
    inline bool useIPv4Only() const{
        bool (NetworkHandler::*rv)() const;
        *((void**)&rv) = dlsym("?useIPv4Only@NetworkHandler@@UEBA_NXZ");
        return (this->*rv)();
    }
    inline  ~NetworkHandler(){
         (NetworkHandler::*rv)();
        *((void**)&rv) = dlsym("??1NetworkHandler@@UEAA@XZ");
        return (this->*rv)();
    }
    inline void _onDisable(){
        void (NetworkHandler::*rv)();
        *((void**)&rv) = dlsym("?_onDisable@NetworkHandler@@EEAAXXZ");
        return (this->*rv)();
    }
    inline void _onEnable(){
        void (NetworkHandler::*rv)();
        *((void**)&rv) = dlsym("?_onEnable@NetworkHandler@@EEAAXXZ");
        return (this->*rv)();
    }
    inline class Social::GameConnectionInfo const & getConnectionInfo() const{
        class Social::GameConnectionInfo const & (NetworkHandler::*rv)() const;
        *((void**)&rv) = dlsym("?getConnectionInfo@NetworkHandler@@UEBAAEBVGameConnectionInfo@Social@@XZ");
        return (this->*rv)();
    }
    inline unsigned short getDefaultGamePort() const{
        unsigned short (NetworkHandler::*rv)() const;
        *((void**)&rv) = dlsym("?getDefaultGamePort@NetworkHandler@@UEBAGXZ");
        return (this->*rv)();
    }
    inline unsigned short getDefaultGamePortv6() const{
        unsigned short (NetworkHandler::*rv)() const;
        *((void**)&rv) = dlsym("?getDefaultGamePortv6@NetworkHandler@@UEBAGXZ");
        return (this->*rv)();
    }
    inline void onAllConnectionsClosed(std::string const & a0, bool a1){
        void (NetworkHandler::*rv)(std::string const &, bool);
        *((void**)&rv) = dlsym("?onAllConnectionsClosed@NetworkHandler@@EEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z");
        return (this->*rv)(std::forward<std::string const &>(a0), std::forward<bool>(a1));
    }
    inline void onAllRemoteConnectionsClosed(std::string const & a0, bool a1){
        void (NetworkHandler::*rv)(std::string const &, bool);
        *((void**)&rv) = dlsym("?onAllRemoteConnectionsClosed@NetworkHandler@@EEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z");
        return (this->*rv)(std::forward<std::string const &>(a0), std::forward<bool>(a1));
    }
    inline void onConnectionClosed(class NetworkIdentifier const & a0, std::string const & a1, bool a2){
        void (NetworkHandler::*rv)(class NetworkIdentifier const &, std::string const &, bool);
        *((void**)&rv) = dlsym("?onConnectionClosed@NetworkHandler@@EEAAXAEBVNetworkIdentifier@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z");
        return (this->*rv)(std::forward<class NetworkIdentifier const &>(a0), std::forward<std::string const &>(a1), std::forward<bool>(a2));
    }
    inline void onNewIncomingConnection(class NetworkIdentifier const & a0, class std::shared_ptr<class NetworkPeer> a1){
        void (NetworkHandler::*rv)(class NetworkIdentifier const &, class std::shared_ptr<class NetworkPeer>);
        *((void**)&rv) = dlsym("?onNewIncomingConnection@NetworkHandler@@EEAAXAEBVNetworkIdentifier@@V?$shared_ptr@VNetworkPeer@@@std@@@Z");
        return (this->*rv)(std::forward<class NetworkIdentifier const &>(a0), std::forward<class std::shared_ptr<class NetworkPeer>>(a1));
    }
    inline void onNewIncomingLocalConnection(class NetworkIdentifier const & a0, class std::shared_ptr<class NetworkPeer> a1){
        void (NetworkHandler::*rv)(class NetworkIdentifier const &, class std::shared_ptr<class NetworkPeer>);
        *((void**)&rv) = dlsym("?onNewIncomingLocalConnection@NetworkHandler@@EEAAXAEBVNetworkIdentifier@@V?$shared_ptr@VNetworkPeer@@@std@@@Z");
        return (this->*rv)(std::forward<class NetworkIdentifier const &>(a0), std::forward<class std::shared_ptr<class NetworkPeer>>(a1));
    }
    inline void onNewOutgoingConnection(class NetworkIdentifier const & a0, class std::shared_ptr<class NetworkPeer> a1){
        void (NetworkHandler::*rv)(class NetworkIdentifier const &, class std::shared_ptr<class NetworkPeer>);
        *((void**)&rv) = dlsym("?onNewOutgoingConnection@NetworkHandler@@EEAAXAEBVNetworkIdentifier@@V?$shared_ptr@VNetworkPeer@@@std@@@Z");
        return (this->*rv)(std::forward<class NetworkIdentifier const &>(a0), std::forward<class std::shared_ptr<class NetworkPeer>>(a1));
    }
    inline void onNewOutgoingLocalConnection(class NetworkIdentifier const & a0, class std::shared_ptr<class NetworkPeer> a1){
        void (NetworkHandler::*rv)(class NetworkIdentifier const &, class std::shared_ptr<class NetworkPeer>);
        *((void**)&rv) = dlsym("?onNewOutgoingLocalConnection@NetworkHandler@@EEAAXAEBVNetworkIdentifier@@V?$shared_ptr@VNetworkPeer@@@std@@@Z");
        return (this->*rv)(std::forward<class NetworkIdentifier const &>(a0), std::forward<class std::shared_ptr<class NetworkPeer>>(a1));
    }
    inline void onOutgoingConnectionFailed(){
        void (NetworkHandler::*rv)();
        *((void**)&rv) = dlsym("?onOutgoingConnectionFailed@NetworkHandler@@EEAAXXZ");
        return (this->*rv)();
    }
    inline void onWebsocketRequest(std::string const & a0, std::string const & a1, class std::function<void (void)> a2){
        void (NetworkHandler::*rv)(std::string const &, std::string const &, class std::function<void (void)>);
        *((void**)&rv) = dlsym("?onWebsocketRequest@NetworkHandler@@EEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0V?$function@$$A6AXXZ@3@@Z");
        return (this->*rv)(std::forward<std::string const &>(a0), std::forward<std::string const &>(a1), std::forward<class std::function<void (void)>>(a2));
    }
    inline bool useIPv6Only() const{
        bool (NetworkHandler::*rv)() const;
        *((void**)&rv) = dlsym("?useIPv6Only@NetworkHandler@@UEBA_NXZ");
        return (this->*rv)();
    }
    */
    MCAPI bool AddConnectionIfNeeded(unsigned __int64, class std::shared_ptr<struct NetherNetInstance> const &);
    MCAPI NetworkHandler(class Scheduler &, std::vector<std::string> const &, struct NetworkHandlerToggles, class Bedrock::NonOwnerPointer<class NetworkDebugManager> const &);
    MCAPI void disconnect();
    MCAPI void enableAsyncFlush(class NetworkIdentifier const &);
    MCAPI void flush(class NetworkIdentifier const &, class std::function<void (void)> &&);
    MCAPI std::vector<std::unique_ptr<class NetworkHandler::Connection>> const & getConnections() const;
    MCAPI class Connector & getConnector();
    MCAPI class std::weak_ptr<class EncryptedNetworkPeer> getEncryptedPeerForUser(class NetworkIdentifier const &);
    MCAPI class NetworkIdentifier getLocalNetworkId() const;
    MCAPI class NetworkStatistics const * getNetworkStatistics() const;
    MCAPI class NetworkPeer * getPeerForUser(class NetworkIdentifier const &);
    MCAPI class NetworkIdentifier getPrimaryNetworkId() const;
    MCAPI class ResourcePackFileUploadManager & getResourcePackUploadManager(class PacketSender &, class NetworkIdentifier const &, std::string const &);
    MCAPI class NetworkIdentifier getServerId() const;
    MCAPI class ServerLocator & getServerLocator();
    MCAPI bool host(struct ConnectionDefinition const &);
    MCAPI void initializeSelectedTransportType();
    MCAPI void initializeServerLocatorTransportType();
    MCAPI bool isHostingPlayer(class NetworkIdentifier const &, unsigned char const &) const;
    MCAPI bool isServer() const;
    MCAPI void registerServerInstance(class NetEventCallback &);
    MCAPI void runEvents(bool);
    MCAPI void send(class NetworkIdentifier const &, class Packet const &, unsigned char);
    MCAPI void sendToMultiple(std::vector<struct NetworkIdentifierWithSubId> const &, class Packet const &);
    MCAPI void setCloseConnection(class NetworkIdentifier const &);
    MCAPI void unregisterClientOrServerInstance(unsigned char const &);
    MCAPI void update(std::vector<class WeakEntityRef> const *);
    MCAPI static class std::shared_ptr<struct NetherNetInstance> mNetherNetInstance;

protected:

private:
    MCAPI class NetworkHandler::Connection * _getConnectionFromId(class NetworkIdentifier const &) const;
    MCAPI void _handlePacketViolation(enum StreamReadResult, enum PacketViolationResponse, enum MinecraftPacketIds, class NetworkIdentifier const &, class NetworkHandler::Connection &, unsigned char, std::string const &);
    MCAPI void _sendInternal(class NetworkIdentifier const &, class Packet const &, std::string const &);
    MCAPI bool _sortAndPacketizeEvents(class NetworkHandler::Connection &, class std::chrono::time_point<struct std::chrono::steady_clock, class std::chrono::duration<__int64, struct std::ratio<1, 1000000000>>>);
    MCAPI void onConnectionClosed(class NetworkIdentifier const &, std::string const &, bool);
    MCAPI void onOutgoingConnectionFailed();

};