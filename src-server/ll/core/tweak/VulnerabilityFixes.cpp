#include "ll/api/event/EventBus.h"
#include "ll/api/event/server/ServerStartedEvent.h"
#include "ll/api/memory/Hook.h"
#include "ll/api/service/Bedrock.h"
#include "mc/certificates/Certificate.h"
#include "mc/certificates/UnverifiedCertificate.h"
#include "mc/deps/raknet/RakPeerInterface.h"
#include "mc/nbt/CompoundTag.h"
#include "mc/nbt/NbtIo.h"
#include "mc/network/NetworkConnection.h"
#include "mc/network/RakPeerHelper.h"
#include "mc/network/ServerNetworkHandler.h"
#include "mc/network/ServerNetworkSystem.h"
#include "mc/network/packet/SubChunkRequestPacket.h"
#include "mc/server/commands/Command.h"
#include "mc/server/commands/CommandOutput.h"
#include "mc/server/commands/CommandVersion.h"
#include "mc/server/commands/MinecraftCommands.h"
#include "mc/server/commands/ServerCommandOrigin.h"
#include "mc/util/IDataInput.h"
#include "mc/world/Minecraft.h"
#include "mc/world/item/Item.h"
#include "mc/world/item/ItemStackBase.h"
#include "nlohmann/json.hpp"

namespace ll::vulnerability_fixes {
LL_TYPE_STATIC_HOOK(
    UnverifiedCertificateHook,
    HookPriority::Highest,
    UnverifiedCertificate,
    &UnverifiedCertificate::fromString,
    UnverifiedCertificate,
    std::string const& input
) {
    if (input.size() <= 0x300000) {
        try {
            auto json = nlohmann::json::parse(input);
            if (json.is_object()) {
                auto& chain = json["chain"];
                if (chain.is_array() && chain.size() <= 10) {
                    return origin(input);
                }
            }
        } catch (...) {}
    }
    return {WebToken(), nullptr};
}

LL_TYPE_INSTANCE_HOOK(
    ValidateCertificateHook,
    HookPriority::Highest,
    Certificate,
    &Certificate::validate,
    bool,
    int64 currentTime,
    bool  isSelfSigned,
    bool  checkExpired
) {
    auto* self = std::launder(this);
    if (self == nullptr) {
        return false;
    }
    return origin(currentTime, isSelfSigned, checkExpired);
}

LL_TYPE_INSTANCE_HOOK(
    ReadUserDataHook,
    HookPriority::Highest,
    Item,
    &Item::$readUserData,
    void,
    ItemStackBase& stack,
    IDataInput&    input,
    ReadOnlyBinaryStream&
) {
    auto marker_result = input.readShortResult();
    if (!marker_result.has_value()) {
        return;
    }
    if (marker_result.value() == -1) {
        auto version_result = input.readByteResult();
        if (!version_result.has_value()) {
            return;
        }
        if (version_result.value() != 1) {
            return;
        }
        if (auto tags = NbtIo::readOrGetEmpty(input)) {
            stack.setUserData(std::move(tags));
        }
    } else if (marker_result.value() != 0) {
        // legacy format?
        return;
    }
    stack.deserializeComponents(input);
}

LL_TYPE_INSTANCE_HOOK(
    DisconnectClientHook,
    HookPriority::Highest,
    ServerNetworkHandler,
    &ServerNetworkHandler::disconnectClientWithMessage,
    void,
    NetworkIdentifier const&         id,
    SubClientId                      subId,
    Connection::DisconnectFailReason discoReason,
    std::string const&               message,
    std::optional<::std::string>     filteredMessage,
    bool                             skipMessage
) {
    origin(id, subId, discoReason, message, filteredMessage, skipMessage);
    // BUGFIX:
    // Close the connection immediately so no further packets from this client can be processed.
    // The original code sends a disconnection packet to the client and waits for the client to confirm.
    // A malicious client may ignore it and keep sending packets, making the server vulnerable to packet spam.
    if (subId == SubClientId::PrimaryClient) {
        mNetwork.onConnectionClosed(id, discoReason, message, false, {});
        mNetwork.getRemoteConnector()->closeNetworkConnection(id);
    }
}

LL_TYPE_INSTANCE_HOOK(
    PeerStartupHook,
    HookPriority::Highest,
    RakPeerHelper,
    &RakPeerHelper::peerStartup,
    RakNet::StartupResult,
    RakNet::RakPeerInterface*   peerIn,
    ConnectionDefinition const& definition,
    RakPeerHelper::PeerPurpose  purpose
) {
    if (peerIn && purpose == PeerPurpose::Gameplay) {
        peerIn->SetLimitIPConnectionFrequency(true); // limit connections from the same ip in 100 milliseconds.
    }
    return origin(peerIn, definition, purpose);
}

LL_TYPE_INSTANCE_HOOK(
    SubChunkRequestHook,
    HookPriority::Highest,
    ServerNetworkHandler,
    &ServerNetworkHandler::$handle,
    void,
    NetworkIdentifier const&     source,
    SubChunkRequestPacket const& packet
) {
    if (packet.mSubChunkPosOffsets->size() > 1000) {
        return;
    }
    return origin(source, packet);
}

void enableFixes() {
    static memory::HookRegistrar<
        UnverifiedCertificateHook,
        ValidateCertificateHook,
        ReadUserDataHook,
        DisconnectClientHook,
        PeerStartupHook,
        SubChunkRequestHook>
        registrar;
    event::EventBus::getInstance().emplaceListener<event::server::ServerStartedEvent>(
        [](event::server::ServerStartedEvent&) {
            // enable packet rate limi
            ServerCommandOrigin origin("Server", ll::service::getLevel()->asServer(), CommandPermissionLevel::Owner, 0);
            auto                command = ll::service::getMinecraft()->mCommands->compileCommand(
                "reloadpacketlimitconfig",
                origin,
                (CurrentCmdVersion)CommandVersion::CurrentVersion(),
                [&](std::string const&) {}
            );
            CommandOutput output(CommandOutputType::Silent);
            command->run(origin, output);
        }
    );
}
} // namespace ll::vulnerability_fixes
