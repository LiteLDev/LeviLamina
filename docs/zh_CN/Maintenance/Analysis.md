## 👓 项目架构分析

> `LiteLoader`是一个基岩版官方服务端`Bedrock Dedicated Server`（以下简称**BDS**）插件框架，提供强大的跨语言脚本插件支持能力和稳定的开发API支持。

正如项目介绍所言，**LiteLoaderBDS** 一个拥有跨语言、跨平台能力的BDS服务端插件框架。

### 跨语言开发能力

**LLSE** 开发之初的想法，便是依靠跨语言引擎的支持，整合多种脚本语言，并给予统一的开发接口，解决相关开发生态破碎的问题。  
实际项目中，使用腾讯开源项目`ScriptX`的跨语言引擎，在对接多种后端的同时，ScriptX 导出了统一的C++接口。  
因此，LLSE在对接BDS时仅维护了1套底层接口，和脚本引擎的对接相当方便。  
目前，`ScriptX`仍在发展之中，新的语言支持还需时日，让我们拭目以待。

<br>

### 模块化，兼容性

LLSE最重要的思想，就是将各重要功能模块化，方便于后续的维护和子项目的升级。基于模块化的设计思想，LLSE将底层加载器接口、多种脚本引擎后端、插件加载模块互相分离，保证各个部分可以单独维护升级，各模块之间尽量降低耦合度，方便进行修改和功能新增。

`LiteLoader ScriptEngine`的架构，可以从此图一眼看出：

![LLSE架构图](Structure.png)

- `LiteLoader`加载器和`ScriptX`两部分提供重要的基础接口
- Kernel内核抽象层负责所有对`LiteLoader`API的调用、Hook函数调用以及对其他底层库函数的调用，并将他们各自的类型抽象为标准的变量类型和STL容器，将各自的接口封装，避免对底层项目的强依赖扩散到上层。
- API接口层为ScriptX脚本引擎提供API接口，引擎将API注入到脚本系统中，在脚本中即是调用相关的API接口完成和BDS的交互
- ScriptX完成对下层脚本引擎的统一抽象，在上层提供一致的接口，为跨语言脚本开发提供基础

同时，由于使用C/C++语言开发，`LiteLoader` 加载器在Linux上同样可以使用 **Wine** 来支持运行，各功能仍能正常工作，且运行性能显著高于Linux原版BDS。使用Linux的开发者们不用担心平台兼容性的问题。

<br>

### 开源项目目录结构介绍

项目使用MSBuild构建系统构建。  
上述的架构落实到实际项目中，项目目录结构如图所示：

```txt
├───docs                  # 文档目录
├───ScriptEngine
│   ├───engine            # 脚本引擎库目录
│   ├───include           # 头文件包含目录
│   ├───lib               # 依赖库目录
│   ├───LiteLoader.Js     # Js项目目录（无源码）
│   ├───LiteLoader.Lua    # Lua项目目录（无源码）
│   ├───Release           # DLL生成目录
│   ├───src               # [核心]源码目录
│   │   ├───API           # API接口层
│   │   └───Kernel        # 核心抽象层
│   └───test              # 测试
├───RELEASE               # 发布目录（用于GitHub Action）
└───ScriptX               # ScriptX源码目录
```

<br>

### 相关底层原理

关于如何从BDS获取底层接口，BDS各大插件框架的方法都大同小异：使用Hook。这里会涉及到很多Windows操作系统底层相关的知识，这也是BDS的C++插件难以开发的原因之一。  

Hook技术，指的是在BDS执行某个函数的时候，通过一些机制修改BDS地址空间中的代码，让其转而先执行一些开发者自己的代码，再返回到BDS执行它原本要执行的东西。这样一来，开发者就可以在BDS中注入自己的逻辑。  

我们可以针对这个函数推测其被调用的原因，并在自己的代码中对这些事件做一些响应，比如说调用其他的BDS函数，或者记录到数据库，或者执行某条命令，甚至是拦截这个函数以达到阻止这个事件发生的目的......总而言之，就是通过Hook来实现一些原版服务器所无法实现的行为。



# 上面都要视情况重写

------



## PluginManager (Loader) 架构分析

PluginManager 部分主要负责的任务是提供插件文件读取、解压等加载相关功能，以及提供插件加载、卸载、查询等接口。LL 和 LLSE 的 Loader 是紧密相连的，LLSE 的 Loader 受 LL 驱动工作。

由于 PluginManager 部分源码较为复杂，为了便于维护者理解，这里对整体工作流程进行梳理

### 插件加载

目前有三种方式会涉及到插件加载的流程：

- 正常启动时加载
- 使用 `ll load` 等语言进行插件热加载
- 在LLSE脚本插件中使用 `ll.require` 加载依赖库

##### 正常启动时加载

- 首先，LL 遍历 plugin 目录加载 dll 插件，同时判定此插件是否已经被 preload 过。如果已经 preload 过的插件则不重复加载
- 接下来，扫描 plugins 目录和 plugins/nodejs 目录，查找是否有符合要求的 LLSE 插件
- 根据配置文件中的选项以及上述查找结果，按需分别**按顺序逐个**启动各语言对应的 LLSE 引擎

- LLSE插件分为三种：单文件插件（如.lua），待解压的插件包（.llplugin），已经解压安装好的插件包。插件包一般用于支持包管理以及多文件分模块的语言，如 NodeJs 和 Python
- 每个 LLSE 引擎启动后，首先遍历 plugins 目录，查找是否有**当前** LLSE 引擎负责加载的语言的插件或者插件包
- 如果检测到自己负责的单文件插件，则直接加载
- 接下来，如果 LLSE 引擎对应的语言支持插件包，则先遍历插件安装目录（如 plugins/nodejs）下的所有文件夹，查找符合要求的插件并加载。最后遍历 plugins，如果检测到未解压的插件包（.llplugin），则解压后调用 `loadPluginPackage` 对插件包进行处理加载

##### 热加载

- 首先，根据传入路径判断是否为 LL native 插件。如果是的话直接由 LL 加载
- 如果不是，则判定是否为 LLSE 插件。此时路径既可以是单文件插件，也可以是 .llplugin 插件包，或者已解压的插件目录
- 如果发现符合插件的要求，则触发一次 ScriptPluginManagerEvent 事件，对所有 LLSE 引擎广播插件热加载请求
- 如果某个LLSE后端发现自己可以处理此请求，则从传递的信息中获取插件路径，并进行加载，返回成功结果
- 如果没有任何一个后端返回成功结果，则输出加载失败

### 插件热卸载

使用 `ll unload` 等语言进行插件热卸载，同样在PluginManager 部分进行处理

- 首先，根据传入插件名，在已注册插件列表中查找插件，如果未查找到直接报错
- 如果查找到对应的插件，且为 LL native 插件，则由 LL 直接进行热卸载
- 如果查找到的标记为 LLSE 脚本插件，则触发一次 ScriptPluginManagerEvent 事件，对所有 LLSE 引擎广播插件热卸载请求
- 如果某个LLSE后端发现自己可以处理此请求，则从传递的信息中获取插件名称，在插件注册列表中查找插件，并进行热卸载，返回结果是否成功
- 如果没有任何一个后端返回成功结果，则输出失败

### 插件热重载

使用 `ll reload` 等语言进行插件热重载，同样在PluginManager 部分进行处理

- 如果 `ll reload`命令没有附带额外的插件名，则表示重载所有插件
- 其实重载插件 = 热卸载插件 + 热加载插件，仅进行依次调用
- 相关逻辑同上
